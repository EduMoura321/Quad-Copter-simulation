#projeto de dinamica de um quadcopter
#modelo 2d
#cinsderando efeitos físicos minimamente idealizados
#13-07-2025
#por: Eduardo Moura Ventorim
#ufms-engenharia física
#============================================================
state = [0, 0, 0, 0, 0, 0, 0, 0] #estado inicial
t_max = 5.0 #tempo de simulação
inputs = [1 * 9.81 / 2  , 1 * 9.81 / 2 ] #entrada de forças
dt = 0.01 #passos
#------------------------------------------------------------
import numpy as np
from Quad_control_sim.UTILS.Plots import graphs
from Quad_control_sim.simulacão.runge_kuta_4 import rk4_step
from Quad_control_sim.controllers.PID import pid_controll
#=============================================================
#parametros físicos (úsuario define):
params = {
    'm': 0.7,        # kg
    'g': 9.81,       # m/s²
    'L': 0.2,        # m
    'I': 0.002,      # kg·m² (estimado)
    'kx': 0.1,       # coef. de arrasto horizontal
    'kz': 0.1,       # coef. de arrasto vertical
    'kt': 0.05,      # amortecimento angular
    'F_max': 15.0,   # N
    't': 0.1         #constante de tempo motor
}
#------------------------------------------------------------
#definir equações de mov base 2 lei
def eqtns(state, inputs, params):
    #retirada de pacote
    x, z, theta, vx, vz, vt, F1,F2 = state
    u1, u2 = inputs
    #parametros
    m = params['m']
    g = params['g']
    L = params['L']
    I = params['I']
    kx = params['kx']
    kz = params['kz']
    kt = params['kt']
    F_max = params['F_max']
    #saturação dos motores(limita seus vaslores)
    u1 = np.clip(u1, 0, F_max)
    u2 = np.clip(u2, 0, F_max)
    #arrastos
    FRX = -kx*vx
    FRZ = -kz*vz
    FRT = -kt*vt
    #equaçoes
    t = params['t']
    DF1 = (u1 - F1) / t
    DF2 = (u2 - F2) / t
    ax = -(F1+F2)*np.sin(theta)/m + FRX/m
    az = (F1 + F2) * np.cos(theta) / m + FRZ / m - g
    at = (F1-F2)*L/I + FRT/I
    #derivadas de estado
    return [vx,vz,vt,ax,az,at, DF1, DF2]
#-----------------------------------------------------------
from Quad_control_sim.simulacão.runge_kuta_4 import rk4_step
# Simulação
states = [state]
t = 0.0
while t < t_max:
    state = rk4_step(eqtns, state, inputs, dt, params)
    states.append(state)
    t += dt
#==========================================================================
#gráficos sem PID
states = np.array(states)

errors = []

time = np.linspace(0, t_max, len(states))

time_errors =  np.arange(0, len(errors)) * dt
zref = 0
graphs(time, time_errors, states, errors, zref)
#==========================================================================
#aplicação do PID para controle de altura
#---------------------------
#definição de parametros
kp = 15.0
ki = 3.2
kd = 12.0
#---------------------------
integ_err = 0
error_i = 0
z_exp = 2
F_max = params['F_max']
errors = []
t = 0
state = [0, 0, 0, 0, 0, 0, 0, 0]
states = [state]
#---------------------------
#simular
while t < t_max:

    z = state[1]

    error = z_exp - z

    uf, int_err, err_or = pid_controll(kp, ki, kd, integ_err, error_i, state, error, dt)

    integ_err = np.clip(int_err, -5.0, 5.0)

    error_i = err_or

    # divisão da força para motores
    u1 = np.clip(uf / 2, 0, F_max)
    u2 = np.clip(uf / 2, 0, F_max)
    inputs = [u1, u2]

    state = rk4_step(eqtns, state, inputs, dt, params)
    states.append(state)

    t += dt

    errors.append(z_exp - z)
#========================================================================================
#novos gráficos gerados com controle PID
errors = np.array(errors)
states = np.array(states)

# espaço amostral de tempos
time = np.linspace(0, dt * (len(states) - 1), len(states))
time_errors =  np.arange(0, len(errors)) * dt

# chamada do plot
graphs(time, time_errors, states, errors, z_exp)
#=========================================================================================
